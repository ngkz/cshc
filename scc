#!/usr/bin/python3

import argparse
import shlex
import subprocess
import sys
import os.path
import shutil
import tempfile
import struct

SELF_DIR = os.path.dirname(os.path.realpath(__file__))
LSS_PATH = os.path.join(SELF_DIR, "linux-syscall-support", "lss")
PREPEND = os.path.join(SELF_DIR, "prepend.h")

class ArchBase:
    OBJCOPY = "objcopy"
    _LINKER_SCRIPT = "linker.ld"
    CFLAGS = ""

    @classmethod
    def LINKER_SCRIPT(cls):
        return os.path.join(SELF_DIR, cls._LINKER_SCRIPT)

class ArchI386(ArchBase):
    CC = "gcc -m32"

class ArchX86_64(ArchBase):
    CC = "gcc"

class ArchARMEL(ArchBase):
    CC = "arm-linux-gnueabi-gcc"
    OBJCOPY = "arm-linux-gnueabi-objcopy"
    _LINKER_SCRIPT = "linker-arm.ld"

class ArchAArch64(ArchBase):
    CC = "aarch64-linux-gnu-gcc"
    CFLAGS = "-mcmodel=tiny"
    OBJCOPY = "aarch64-linux-gnu-objcopy"
    _LINKER_SCRIPT = "linker-aarch64.ld"

class ArchPowerPC(ArchBase):
    CC = "powerpc-linux-gnu-gcc"

ARCH = {
    "i386": ArchI386,
    "x86_64": ArchX86_64,
    "armel": ArchARMEL,
    "aarch64": ArchAArch64,
    #"ppc": ArchPowerPC
}

def execute(verbose, cmd):
    if verbose:
        print(cmd)

    retcode = subprocess.call(cmd, shell = True)
    if retcode != 0:
        sys.exit(retcode)

parser = argparse.ArgumentParser(description = 'scc - C Shellcode Compiler')
parser.add_argument('srcpath', help = 'source code file')
parser.add_argument('-o', metavar = "<file>", dest = 'outpath', help = 'place the output into <file>')
parser.add_argument('-a', '--arch', choices = ("i386", "x86_64", "armel", "arm", "aarch64", "mips", "ppc"), default = "i386", help = 'target architecture')
parser.add_argument('-v', help = 'verbose mode', action = 'store_true', dest = 'verbose')
parser.add_argument('-e', '--encoder', choices = ("alnum", "cstring"), help = 'encode shellcode')
parser.add_argument('-n', help = 'output elf executable with default linker script.', action = 'store_true', dest = 'normal_elf')
parser.add_argument('-S', help = 'compile only.', action = 'store_true', dest = 'compile_only')

args = parser.parse_args()

cmd = ARCH[args.arch].CC
cmd += " -pie -O3 -fPIE -Winline -finline-functions -ffreestanding -fomit-frame-pointer -fno-zero-initialized-in-bss -isystem {} -include {} -Wl,-s -nostdlib -nodefaultlibs -nostartfiles".format(shlex.quote(LSS_PATH), shlex.quote(PREPEND))
cmd += " " + ARCH[args.arch].CFLAGS

if args.compile_only:
    cmd += " -S"

if not args.normal_elf:
    cmd += " -Wl,-T," + shlex.quote(ARCH[args.arch].LINKER_SCRIPT())

if args.outpath is None:
    args.outpath = "a.out"
cmd += " -o " + shlex.quote(args.outpath)

if args.verbose:
    cmd += " -Wl,-M"

cmd += " " + shlex.quote(args.srcpath)

execute(args.verbose, cmd)

if not args.normal_elf and not args.compile_only:
    tmpdir = tempfile.mkdtemp()
    try:
        rela_file = os.path.join(tmpdir, "rela")
        if args.arch == "aarch64":
            cmd = "{} -O binary -j .rela.entry {} {}".format(
                    ARCH[args.arch].OBJCOPY, shlex.quote(args.outpath), shlex.quote(rela_file))
            execute(args.verbose, cmd)

        cmd = "{} -O binary -j .text {}".format(ARCH[args.arch].OBJCOPY, shlex.quote(args.outpath))
        execute(args.verbose, cmd)

        if args.arch == "aarch64":
            with open(args.outpath, "r+b") as shellcode_file:
                with open(rela_file, "rb") as rela_file:
                    while True:
                        rela = rela_file.read(8 * 3)
                        if len(rela) == 0:
                            break
                        r_offset, r_info, r_addend = struct.unpack("<QQQ", rela)
                        assert r_info & 0xffffffff == 1027, "unsupported relocation entry" #R_AARCH64_RELATIVE
                        shellcode_file.seek(r_offset)
                        shellcode_file.write(struct.pack("<Q", r_addend))
    finally:
        shutil.rmtree(tmpdir)

if not args.encoder is None:
    #TODO
    pass


